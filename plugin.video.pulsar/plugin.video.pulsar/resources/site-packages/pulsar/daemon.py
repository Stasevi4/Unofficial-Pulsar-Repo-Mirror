import sys
import subprocess
import os
import signal
import stat
import xbmc
import xbmcaddon
import urllib2
import threading
import time
from pulsar.logger import log
from pulsar.config import PULSARD_HOST
from pulsar.platform import PLATFORM
from pulsar.addon import ADDON, ADDON_ID
from pulsar.util import notify


SW_HIDE = 0
STARTF_USESHOWWINDOW = 1


def ensure_exec_perms(file_):
    st = os.stat(file_)
    os.chmod(file_, st.st_mode | stat.S_IEXEC)
    return file_


def android_get_current_appid():
    uid = os.getuid()
    with open("/proc/%d/cmdline", uid) as fp:
        return fp.read().rstrip()


def get_pulsard_checksum(path):
    with open(path) as fp:
        fp.seek(-40, os.SEEK_END) # we put a sha1 there
        return fp.read()


def get_pulsar_binary():
    binary = "pulsar" + (PLATFORM["os"] == "windows" and ".exe" or "")

    platform = PLATFORM.copy()
    if platform["os"] == "darwin": # 64 bits anyway on Darwin
        platform["arch"] = "x64"
    elif platform["os"] == "windows": # 32 bits anyway on Windows
        platform["arch"] = "x86"

    binary_dir = os.path.join(ADDON.getAddonInfo("path"), "resources", "bin", "%(os)s_%(arch)s" % platform)
    if platform["os"] == "android":
        app_id = android_get_current_appid()
        xbmc_data_path = os.path.join("/data", "data", app_id)
        if os.path.exists(xbmc_data_path) and uid == os.stat(xbmc_data_path).st_uid:
            binary_dir = os.path.join(xbmc_data_path, "files", ADDON_ID)
    else:
        dest_binary_dir = os.path.join(xbmc.translatePath(ADDON.getAddonInfo("profile")), "bin", "%(os)s_%(arch)s" % platform)

    binary_path = os.path.join(binary_dir, binary)
    dest_binary_path = os.path.join(dest_binary_dir, binary)

    if not os.path.exists(dest_binary_path) or get_pulsard_checksum(dest_binary_path) != get_pulsard_checksum(binary_path):
        log.info("Updating pulsar daemon...")
        import shutil
        try:
            os.makedirs(dest_binary_dir)
        except OSError:
            pass
        try:
            shutil.rmtree(dest_binary_dir)
        except:
            pass
        shutil.copytree(binary_dir, dest_binary_dir)

    return dest_binary_dir, ensure_exec_perms(dest_binary_path)


def start_pulsard(**kwargs):
    # Make sure all other pulsard instances are closed
    try:
        urllib2.urlopen(PULSARD_HOST + "/shutdown")
    except urllib2.URLError:
        pass
    pulsar_dir, pulsar_binary = get_pulsar_binary()
    args = [pulsar_binary]
    kwargs["cwd"] = pulsar_dir
    if PLATFORM["os"] == "windows":
        si = subprocess.STARTUPINFO()
        si.dwFlags = STARTF_USESHOWWINDOW
        si.wShowWindow = SW_HIDE
        kwargs["startupinfo"] = si
    return subprocess.Popen(args, **kwargs)


def wait_for_abortRequested(proc, monitor):
    monitor.closing.wait()
    log.info("pulsard: exiting pulsard daemon")
    proc.terminate()
    log.info("pulsard: pulsard daemon exited")


def pulsard_thread(monitor):
    while not xbmc.abortRequested:
        log.info("pulsard: starting pulsard")
        proc = start_pulsard(stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        threading.Thread(target=wait_for_abortRequested, args=[proc, monitor]).start()
        while proc.poll() is None:
            log.info(proc.stdout.readline())
        if proc.returncode == 0 or xbmc.abortRequested:
            break
        notify("Pulsar has crashed, restarting...", time=1000)
